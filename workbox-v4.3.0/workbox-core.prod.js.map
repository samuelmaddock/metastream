{"version":3,"file":"workbox-core.prod.js","sources":["../_version.mjs","../_private/logger.mjs","../models/messages/messageGenerator.mjs","../_private/WorkboxError.mjs","../_private/assert.mjs","../_private/quota.mjs","../_private/DBWrapper.mjs","../_private/deleteDatabase.mjs","../_private/cacheNames.mjs","../models/pluginEvents.mjs","../utils/pluginUtils.mjs","../_private/getFriendlyURL.mjs","../_private/cacheWrapper.mjs","../_private/fetchWrapper.mjs","../cacheNames.mjs","../index.mjs","../clientsClaim.mjs","../setCacheNameDetails.mjs","../skipWaiting.mjs"],"sourcesContent":["try{self['workbox:core:4.3.0']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\n  let inGroup = false;\n\n  const methodToColorMap = {\n    debug: `#7f8c8d`, // Gray\n    log: `#2ecc71`, // Green\n    warn: `#f39c12`, // Yellow\n    error: `#c0392b`, // Red\n    groupCollapsed: `#3498db`, // Blue\n    groupEnd: null, // No colored prefix on groupEnd\n  };\n\n  const print = function(method, args) {\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        console[method](...args);\n        return;\n      }\n    }\n\n    const styles = [\n      `background: ${methodToColorMap[method]}`,\n      `border-radius: 0.5em`,\n      `color: white`,\n      `font-weight: bold`,\n      `padding: 2px 0.5em`,\n    ];\n\n    // When in a group, the workbox prefix is not displayed.\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n    console[method](...logPrefix, ...args);\n\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n\n  const api = {};\n  for (const method of Object.keys(methodToColorMap)) {\n    api[method] = (...args) => {\n      print(method, args);\n    };\n  }\n\n  return api;\n})();\n\nexport {logger};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messages} from './messages.mjs';\nimport '../../_version.mjs';\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\n\nconst generatorFunction = (code, ...args) => {\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(...args);\n};\n\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\n    fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messageGenerator} from '../models/messages/messageGenerator.mjs';\nimport '../_version.mjs';\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    let message = messageGenerator(errorCode, details);\n\n    super(message);\n\n    this.name = errorCode;\n    this.details = details;\n  }\n}\n\nexport {WorkboxError};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\nimport '../_version.mjs';\n\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSWEnv = (moduleName) => {\n  if (!('ServiceWorkerGlobalScope' in self)) {\n    throw new WorkboxError('not-in-sw', {moduleName});\n  }\n};\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\n  if (!Array.isArray(value)) {\n    throw new WorkboxError('not-an-array', {\n      moduleName,\n      className,\n      funcName,\n      paramName,\n    });\n  }\n};\n\nconst hasMethod = (object, expectedMethod,\n    {moduleName, className, funcName, paramName}) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\n      moduleName, className, funcName});\n  }\n};\n\nconst isType = (object, expectedType,\n    {moduleName, className, funcName, paramName}) => {\n  if (typeof object !== expectedType) {\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\n      moduleName, className, funcName});\n  }\n};\n\nconst isInstance = (object, expectedClass,\n    {moduleName, className, funcName,\n      paramName, isReturnValueProblem}) => {\n  if (!(object instanceof expectedClass)) {\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\n      moduleName, className, funcName, isReturnValueProblem});\n  }\n};\n\nconst isOneOf = (value, validValues, {paramName}) => {\n  if (!validValues.includes(value)) {\n    throw new WorkboxError('invalid-value', {\n      paramName,\n      value,\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\n    });\n  }\n};\n\nconst isArrayOfClass = (value, expectedClass,\n    {moduleName, className, funcName, paramName}) => {\n  const error = new WorkboxError('not-array-of-class', {\n    value, expectedClass,\n    moduleName, className, funcName, paramName,\n  });\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (let item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isSWEnv,\n  isType,\n  isArrayOfClass,\n};\n\nexport {finalAssertExports as assert};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\n\nimport '../_version.mjs';\n\nconst callbacks = new Set();\n\n/**\n * Adds a function to the set of callbacks that will be executed when there's\n * a quota error.\n *\n * @param {Function} callback\n * @memberof workbox.core\n */\nfunction registerQuotaErrorCallback(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(callback, 'function', {\n      moduleName: 'workbox-core',\n      funcName: 'register',\n      paramName: 'callback',\n    });\n  }\n\n  callbacks.add(callback);\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Registered a callback to respond to quota errors.', callback);\n  }\n}\n\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox.core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log(`About to run ${callbacks.size} callbacks to clean up caches.`);\n  }\n\n  for (const callback of callbacks) {\n    await callback();\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(callback, 'is complete.');\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Finished running callbacks.');\n  }\n}\n\nexport {\n  executeQuotaErrorCallbacks,\n  registerQuotaErrorCallback,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange,\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange;\n\n    // If this is null, it means the database isn't open.\n    this._db = null;\n  }\n\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   *\n   * @private\n   */\n  get db() {\n    return this._db;\n  }\n\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n  async open() {\n    if (this._db) return;\n\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = () => reject(openRequest.error);\n      openRequest.onupgradeneeded = (evt) => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = ({target}) => {\n        const db = target.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n\n    return this;\n  }\n\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {query, count});\n  }\n\n\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAllKeys(storeName, query, count) {\n    return (await this.getAllMatching(\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\n  }\n\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n  async getAllMatching(storeName, {\n    index,\n    query = null, // IE errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys,\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n\n      target.openCursor(query, direction).onsuccess = ({target}) => {\n        const cursor = target.result;\n        if (cursor) {\n          const {primaryKey, key, value} = cursor;\n          results.push(includeKeys ? {primaryKey, key, value} : value);\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      txn.onabort = ({target}) => reject(target.error);\n      txn.oncomplete = () => resolve();\n\n      callback(txn, (value) => resolve(value));\n    });\n  }\n\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\n        done(target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   *\n   * @private\n   */\n  _onversionchange() {\n    this.close();\n  }\n\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n  close() {\n    if (this._db) {\n      this._db.close();\n      this._db = null;\n    }\n  }\n}\n\n// Exposed to let users modify the default timeout on a per-instance\n// or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  'readwrite': ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Deletes the database.\n * Note: this is exported separately from the DBWrapper module because most\n * usages of IndexedDB in workbox dont need deleting, and this way it can be\n * reused in tests to delete databases without creating DBWrapper instances.\n *\n * @param {string} name The database name.\n * @private\n */\nexport const deleteDatabase = async (name) => {\n  await new Promise((resolve, reject) => {\n    const request = indexedDB.deleteDatabase(name);\n    request.onerror = ({target}) => {\n      reject(target.error);\n    };\n    request.onblocked = () => {\n      reject(new Error('Delete blocked'));\n    };\n    request.onsuccess = () => {\n      resolve();\n    };\n  });\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: self.registration.scope,\n};\n\nconst _createCacheName = (cacheName) => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n      .filter((value) => value.length > 0)\n      .join('-');\n};\n\nexport const cacheNames = {\n  updateDetails: (details) => {\n    Object.keys(_cacheNameDetails).forEach((key) => {\n      if (typeof details[key] !== 'undefined') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getPrefix: () => {\n    return _cacheNameDetails.prefix;\n  },\n  getRuntimeName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n  getSuffix: () => {\n    return _cacheNameDetails.suffix;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nexport const pluginEvents = {\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\n  CACHE_KEY_WILL_BE_USED: 'cacheKeyWillBeUsed',\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n  FETCH_DID_FAIL: 'fetchDidFail',\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\n  REQUEST_WILL_FETCH: 'requestWillFetch',\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const pluginUtils = {\n  filter: (plugins, callbackName) => {\n    return plugins.filter((plugin) => callbackName in plugin);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nexport {getFriendlyURL};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {assert} from './assert.mjs';\nimport {executeQuotaErrorCallbacks} from './quota.mjs';\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\nimport {logger} from './logger.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions,\n} = {}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method,\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'write'});\n\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` +\n        `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url),\n    });\n  }\n\n  let responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest,\n  });\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n      `not be cached.`, responseToCache);\n    }\n    return;\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n      await matchWrapper({cacheName, matchOptions, request: effectiveRequest}) :\n      null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = [],\n}) => {\n  const cache = await caches.open(cacheName);\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'read'});\n\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\n          .call(plugin, {\n            cacheName,\n            event,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n          });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\n          .call(plugin, {\n            request,\n            response: responseToCache,\n            event,\n          });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          logger.warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({request, mode, plugins}) => {\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\n\n  let effectiveRequest = request;\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(\n        plugin, {mode, request: effectiveRequest});\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\n        isReturnValueProblem: true,\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` +\n          `'${getFriendlyURL(request.url)}'`);\n      }\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch',\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(\n      plugins, pluginEvents.FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event,\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse;\n\n    // See https://github.com/GoogleChrome/workbox/issues/1796\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for `+\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\n      `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\n            .call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse,\n            });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for `+\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch,\n};\n\nexport {fetchWrapper};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames as _cacheNames} from './_private/cacheNames.mjs';\nimport './_version.mjs';\n\n\n/**\n * Get the current cache names and prefix/suffix used by Workbox.\n *\n * `cacheNames.precache` is used for precached assets,\n * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\n * store `analytics.js`, and `cacheNames.runtime` is used for everything else.\n *\n * `cacheNames.prefix` can be used to retrieve just the current prefix value.\n * `cacheNames.suffix` can be used to retrieve just the current suffix value.\n *\n * @return {Object} An object with `precache`, `runtime`, `prefix`, and\n *     `googleAnalytics` properties.\n *\n * @alias workbox.core.cacheNames\n */\nexport const cacheNames = {\n  get googleAnalytics() {\n    return _cacheNames.getGoogleAnalyticsName();\n  },\n  get precache() {\n    return _cacheNames.getPrecacheName();\n  },\n  get prefix() {\n    return _cacheNames.getPrefix();\n  },\n  get runtime() {\n    return _cacheNames.getRuntimeName();\n  },\n  get suffix() {\n    return _cacheNames.getSuffix();\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {registerQuotaErrorCallback} from './registerQuotaErrorCallback.mjs';\nimport * as _private from './_private.mjs';\nimport {clientsClaim} from './clientsClaim.mjs';\nimport {cacheNames} from './cacheNames.mjs';\nimport {setCacheNameDetails} from './setCacheNameDetails.mjs';\nimport {skipWaiting} from './skipWaiting.mjs';\nimport './_version.mjs';\n\n\n// Give our version strings something to hang off of.\ntry {\n  self.workbox.v = self.workbox.v || {};\n} catch (errer) {\n  // NOOP\n}\n\n/**\n * All of the Workbox service worker libraries use workbox-core for shared\n * code as well as setting default values that need to be shared (like cache\n * names).\n *\n * @namespace workbox.core\n */\n\nexport {\n  _private,\n  clientsClaim,\n  cacheNames,\n  registerQuotaErrorCallback,\n  setCacheNameDetails,\n  skipWaiting,\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Claim any currently available clients once the service worker\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\n *\n * @alias workbox.core.clientsClaim\n */\nexport const clientsClaim = () => {\n  addEventListener('activate', () => clients.claim());\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from './_private/assert.mjs';\nimport {cacheNames} from './_private/cacheNames.mjs';\nimport {WorkboxError} from './_private/WorkboxError.mjs';\nimport './_version.mjs';\n\n\n/**\n * Modifies the default cache names used by the Workbox packages.\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n *\n * @param {Object} details\n * @param {Object} [details.prefix] The string to add to the beginning of\n *     the precache and runtime cache names.\n * @param {Object} [details.suffix] The string to add to the end of\n *     the precache and runtime cache names.\n * @param {Object} [details.precache] The cache name to use for precache\n *     caching.\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\n * @param {Object} [details.googleAnalytics] The cache name to use for\n *     `workbox-google-analytics` caching.\n *\n * @alias workbox.core.setCacheNameDetails\n */\nexport const setCacheNameDetails = (details) => {\n  if (process.env.NODE_ENV !== 'production') {\n    Object.keys(details).forEach((key) => {\n      assert.isType(details[key], 'string', {\n        moduleName: 'workbox-core',\n        funcName: 'setCacheNameDetails',\n        paramName: `details.${key}`,\n      });\n    });\n\n    if ('precache' in details && details.precache.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'precache',\n        value: details.precache,\n      });\n    }\n\n    if ('runtime' in details && details.runtime.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'runtime',\n        value: details.runtime,\n      });\n    }\n\n    if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'googleAnalytics',\n        value: details.googleAnalytics,\n      });\n    }\n  }\n\n  cacheNames.updateDetails(details);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Force a service worker to become active, instead of waiting. This is\n * normally used in conjunction with `clientsClaim()`.\n *\n * @alias workbox.core.skipWaiting\n */\nexport const skipWaiting = () => {\n  // We need to explicitly call `self.skipWaiting()` here because we're\n  // shadowing `skipWaiting` with this local function.\n  addEventListener('install', () => self.skipWaiting());\n};\n"],"names":["self","_","e","messageGenerator","code","args","msg","length","JSON","stringify","WorkboxError","Error","constructor","errorCode","details","name","callbacks","Set","DBWrapper","version","onupgradeneeded","onversionchange","this","_onversionchange","_name","_version","_onupgradeneeded","_db","Promise","resolve","reject","openRequestTimedOut","setTimeout","OPEN_TIMEOUT","openRequest","indexedDB","open","onerror","error","evt","transaction","abort","target","result","close","onsuccess","db","bind","storeName","query","getAllKeys","count","getAllMatching","includeKeys","map","key","index","direction","txn","done","store","objectStore","results","openCursor","cursor","primaryKey","value","push","continue","storeNames","type","callback","onabort","oncomplete","method","prototype","methodsToWrap","mode","methods","Object","entries","IDBObjectStore","async","_call","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","cacheName","filter","join","cacheNames","updateDetails","keys","forEach","getGoogleAnalyticsName","userCacheName","getPrecacheName","getPrefix","getRuntimeName","getSuffix","pluginEvents","pluginUtils","plugins","callbackName","plugin","getFriendlyURL","url","urlObj","URL","location","origin","pathname","href","matchWrapper","request","event","matchOptions","cache","caches","effectiveRequest","_getEffectiveRequest","cachedResponse","match","call","_isResponseSafeToCache","response","responseToCache","pluginsUsed","status","cacheKeyWillBeUsedPlugins","Request","cacheWrapper","put","updatePlugins","oldResponse","executeQuotaErrorCallbacks","newResponse","fetchWrapper","fetch","fetchOptions","preloadResponse","possiblePreloadResponse","failedFetchPlugins","originalRequest","clone","err","thrownError","pluginFilteredRequest","fetchResponse","deleteDatabase","onblocked","process","_cacheNames","workbox","v","errer","addEventListener","clients","claim","add","skipWaiting"],"mappings":"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"}